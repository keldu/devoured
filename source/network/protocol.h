#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <optional>

namespace dvr {
	class AsyncInputStream;
	class AsyncOutputStream;
	/* 
	 * Don't change the Message types without changing the corresponding max size in network.cpp
	 * I'm wondering if there exists some kind of template magic to autogenerate the sizes
	 * with some helper classes based on the current class Definition.
	 * I would love to have a autogenerated network messages based on the provided class.
	 *
	 * This propably involves some interface for serializable message types and constexpr
	 */
	class MessageRequest {
	public:
		MessageRequest() = default;
		MessageRequest(uint16_t, uint8_t, const std::string&, const std::string&);
		uint16_t request_id;
		uint8_t type;
		std::string target;
		std::string content;
	};
	/*
	 * Same here as above
	 */
	enum class ReturnCode: uint8_t{
		OK,
		NOSERVICE
	};
	class MessageResponse {
	public:
		MessageResponse() = default;
		MessageResponse(uint16_t, uint8_t, const std::string&, const std::string&);
		uint16_t request_id;
		uint8_t return_code;
		std::string target;
		std::string content;
	};

	std::ostream& operator<<(std::ostream& stream, const MessageRequest& request);
	std::ostream& operator<<(std::ostream& stream, const MessageResponse& response);

	bool serializeMessageRequest(std::vector<uint8_t>& buffer, MessageRequest& request);
	bool deserializeMessageRequest(std::vector<uint8_t>& buffer, MessageRequest& request);

	bool serializeMessageResponse(std::vector<uint8_t>& buffer, MessageResponse& response);
	bool deserializeMessageResponse(std::vector<uint8_t>& buffer, MessageResponse& response);
	
	std::optional<MessageRequest> asyncReadRequest(AsyncInputStream& connection);
	bool asyncWriteRequest(AsyncOutputStream& connection, const MessageRequest& request);
	
	std::optional<MessageResponse> asyncReadResponse(AsyncInputStream& connection);
	bool asyncWriteResponse(AsyncOutputStream& connection, const MessageResponse& request);
}
